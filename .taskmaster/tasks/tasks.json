{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository and Environment Configuration",
        "description": "Initialize the project repository with React.js frontend, Node.js/Express.js backend, and MongoDB setup. Configure environment variables management using dotenv and ensure .env is gitignored.",
        "details": "Create a monorepo or separate repos for frontend and backend. Initialize React 18+ with Vite or Create React App for SPA. Setup Node.js 18+ with Express 4.x for REST API. Use Mongoose 7.x for MongoDB ODM. Configure dotenv for environment variables and add .env to .gitignore. Setup ESLint and Prettier for code quality and SonarQube integration for security checks. Use Passport.js 0.6.x for OAuth integration later.",
        "testStrategy": "Verify repository initialization by running frontend and backend servers locally. Confirm environment variables load correctly and .env is excluded from git commits. Run linting and SonarQube scans to ensure no security issues.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Admin Panel Foundation and Venue Verification Queue",
        "description": "Develop secure admin login and a venue verification queue to approve or reject new venue submissions, forming the foundation for venue onboarding.",
        "details": "Use React with React Router for admin SPA. Implement backend REST endpoints for admin authentication and venue verification management. Use Passport.js with local strategy or OAuth for admin login. Store admin credentials securely in MongoDB with hashed passwords (bcrypt 5.x). Create venue verification queue UI with approve/reject actions. Ensure role-based access control (RBAC) middleware on backend routes.",
        "testStrategy": "Test admin login with valid and invalid credentials. Verify venue submissions appear in the queue. Test approve/reject actions update venue status in DB. Confirm unauthorized users cannot access admin routes.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Build Venue Onboarding Flow for Venue Owners",
        "description": "Create the onboarding process for venue owners to submit court details for verification, enabling venue data collection for the platform.",
        "status": "pending",
        "dependencies": [
          2,
          12
        ],
        "priority": "high",
        "details": "Implement frontend forms for venue owners to input venue details, location (use Google Maps API for address autocomplete), operating hours, and upload images. Backend endpoints built with Rust using Actix Web or Axum framework to receive and store venue data with verification status set to pending. Use official MongoDB Rust driver for database integration. Validate inputs on frontend and backend with proper error handling. Use MongoDB schema for Venue with fields as per PRD.",
        "testStrategy": "Validate form input constraints and error handling. Submit venue data and verify it appears in admin verification queue. Test image upload and storage. Confirm data integrity in MongoDB. Test Rust backend endpoints for proper error handling and MongoDB integration.",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement User Authentication and Profile Management",
        "description": "Develop user registration (email and OAuth SSO with Google and Facebook), login, role selection (Player or Venue Owner), and editable player profile with matchmaking preferences.",
        "status": "pending",
        "dependencies": [
          1,
          12
        ],
        "priority": "high",
        "details": "Backend authentication implemented in Rust using oauth2 and jsonwebtoken crates for OAuth SSO and JWT token management. Use Actix Web or Axum framework with MongoDB integration via the official Rust driver. Store user data in MongoDB with roles and nested profile object including skill level, play style, and availability. Implement frontend registration/login forms and profile management pages with React Hook Form and validation. Secure API endpoints with JWT authentication.",
        "testStrategy": "Test registration and login flows for email and OAuth. Verify role selection persists. Edit and save profile preferences and confirm data updates in DB. Test authentication middleware protects routes. Validate Rust backend integration with MongoDB and JWT token generation/verification.",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop Venue Dashboard with Calendar View for Schedule Management",
        "description": "Create a dashboard for venue owners to manage court availability, view bookings, and block off times using a calendar interface.",
        "details": "Use React with a calendar library like FullCalendar 6.x or React Big Calendar for UI. Backend endpoints implemented in Rust with Actix Web or Axum framework to fetch and update venue availability and bookings. Implement blocking/unblocking time slots. Ensure real-time updates with polling or WebSocket (optional for MVP). Store schedule data in MongoDB using official Rust driver linked to Venue and GameSession models.",
        "testStrategy": "Test calendar displays correct availability and bookings. Verify blocking/unblocking updates backend and UI. Confirm only venue owners can access and modify their schedules.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Game Session Management for Players",
        "description": "Allow players to create, view, and join game sessions with logic for auto-cancellation if minimum player count is not met.",
        "details": "Design GameSession schema with venue, time, required players, joined players with status, and session status. Backend endpoints implemented in Rust with Actix Web or Axum framework for session CRUD and joining logic. Implement auto-cancellation job using Rust cron library or scheduled tasks to cancel sessions not meeting minimum players before start time. Frontend UI for session creation, listing, and joining with status updates.",
        "testStrategy": "Create sessions and verify data stored correctly. Join sessions and check player status updates. Test auto-cancellation triggers correctly. Validate UI reflects session states accurately.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Generate Unique QR Codes for Each Booking",
        "description": "Implement QR code generation for game sessions accessible from the venue dashboard to facilitate check-ins.",
        "details": "Use a Rust QR code library like 'qrcode' or 'qrcode-generator' for backend generation. Each QR code encodes a unique session and player identifier. Store QR code data or generate on-demand. Integrate QR code display in venue dashboard and player session views using React frontend.",
        "testStrategy": "Generate QR codes for sessions and verify scannability with standard QR scanners. Confirm QR codes encode correct session/player info. Test UI integration and accessibility.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement QR Code Check-in Functionality",
        "description": "Develop the ability for players to scan QR codes to prove attendance at game sessions, enabling attendance verification.",
        "details": "Use a React QR code scanner library like 'react-qr-reader' 3.x for frontend scanning. Backend API implemented in Rust with Actix Web or Axum framework to validate scanned QR code data, update player check-in status in GameSession. Secure endpoints to prevent spoofing. Provide UI feedback on successful or failed check-in.",
        "testStrategy": "Test scanning QR codes with various devices. Verify backend updates check-in status correctly. Test error handling for invalid or duplicate scans.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Build Reputation and Trust System",
        "description": "Add functionality for players to report no-shows and rate venues after completed and checked-in games to foster community trust.",
        "details": "Extend GameSession and User schemas to store ratings and reports. Backend endpoints implemented in Rust with Actix Web or Axum framework to submit ratings and no-show reports. Frontend UI for rating venues and reporting no-shows post-session. Implement aggregation logic for venue ratings. Ensure only checked-in players can rate/report.",
        "testStrategy": "Submit ratings and reports and verify persistence. Confirm only eligible users can submit. Test aggregation and display of venue ratings. Validate UI flows and error handling.",
        "priority": "medium",
        "dependencies": [
          6,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Integrate AI Chat Interface with Google Gemini API",
        "description": "Develop frontend chat interface and backend API integration with Google Gemini API for conversational matchmaking in English and Bahasa Indonesia.",
        "details": "Frontend chat UI with React using a chat component library or custom implementation supporting multilingual input. Backend API implemented in Rust with Actix Web or Axum framework to send user queries to Google Gemini API with proper prompt engineering and caching for common queries to reduce costs. Handle API responses and display matchmaking recommendations. Implement fallback deterministic filters for initial MVP. Use Google Gemini API latest version with secure API key management.",
        "testStrategy": "Test chat interface usability and responsiveness. Validate API calls and responses. Confirm recommendations are relevant and multilingual support works. Test caching and error handling.",
        "priority": "medium",
        "dependencies": [
          4,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Generate Secure Secrets and Environment Management Script",
        "description": "Create cryptographically secure JWT_SECRET and SESSION_SECRET using OpenSSL and implement a script to safely update environment variables, addressing security vulnerabilities from placeholder secrets.",
        "details": "Use OpenSSL to generate cryptographically secure secrets: `openssl rand -base64 64` for JWT_SECRET (minimum 64 bytes) and `openssl rand -base64 32` for SESSION_SECRET. Create a secure-secrets.js script that:\n\n1. Generates new secrets using OpenSSL via child_process\n2. Validates secret length and complexity requirements\n3. Updates the .env file programmatically while preserving other variables\n4. Creates backup of existing .env file before modification\n5. Provides option to generate secrets without overwriting existing ones\n6. Includes proper error handling for OpenSSL execution failures\n\nImplement security best practices:\n- Ensure secrets are never logged to console\n- Validate minimum entropy requirements\n- Use proper file permissions (chmod 600 for .env)\n- Include validation that .env is gitignored\n- Add documentation for production deployment procedures\n\nThe script should be executable via npm script: `npm run generate-secrets`",
        "testStrategy": "1. Run the script and verify new secure secrets are generated with proper length\n2. Confirm .env file is updated correctly with new secrets while preserving other variables\n3. Test backup functionality by checking .env.backup creation\n4. Verify error handling when OpenSSL is not available\n5. Test that existing secrets are not overwritten when using dry-run mode\n6. Validate script execution via npm script\n7. Confirm secrets meet minimum cryptographic strength requirements (64+ bytes for JWT, 32+ bytes for session)\n8. Test that script fails gracefully if .env file doesn't exist",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Migrate Backend from Node.js/Express.js to Rust with Actix Web Framework",
        "description": "Complete migration of the existing Node.js/Express.js backend to Rust using Actix Web framework, maintaining API compatibility and improving performance",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          1,
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Rust project structure and dependencies",
            "description": "Initialize a new Rust project with Actix Web framework and configure Cargo.toml with necessary dependencies including database drivers, authentication libraries, and middleware components.",
            "dependencies": [],
            "details": "Create a new Rust project using cargo new. Add actix-web, serde, jsonwebtoken, oauth2, mongodb, and other required crates to Cargo.toml. Set up project directory structure mirroring the Node.js backend with src/bin for server, src/models, src/routes, src/middleware, and src/config modules.",
            "status": "pending",
            "testStrategy": "Verify project builds successfully with cargo build and all dependencies resolve without errors."
          },
          {
            "id": 2,
            "title": "Migrate database configuration and connection setup",
            "description": "Translate the existing database.js configuration to Rust using the MongoDB driver, establishing connection pooling and error handling.",
            "dependencies": [
              "12.1"
            ],
            "details": "Implement a config module to handle database connection strings and settings from environment variables. Use mongodb crate to create a connection pool with proper error handling. Ensure connection is reusable across the application similar to the Node.js implementation.",
            "status": "pending",
            "testStrategy": "Test database connection establishment and verify successful ping operation to the database."
          },
          {
            "id": 3,
            "title": "Implement data models in Rust with Serde",
            "description": "Convert User.js and Venue.js models to Rust structs with Serde serialization/deserialization for MongoDB integration.",
            "dependencies": [
              "12.2"
            ],
            "details": "Create Rust structs for User and Venue with appropriate fields matching the JavaScript models. Use serde and mongodb derive macros for serialization/deserialization. Implement From traits for conversion between BSON and Rust types. Ensure all model validations are preserved.",
            "status": "pending",
            "testStrategy": "Test serialization/deserialization of model objects and verify data integrity when saving/retrieving from database."
          },
          {
            "id": 4,
            "title": "Migrate authentication middleware and JWT handling",
            "description": "Convert auth.js middleware to Rust Actix middleware with JWT token verification and OAuth2 integration.",
            "dependencies": [
              "12.1",
              "12.3"
            ],
            "details": "Implement Actix Web middleware for JWT authentication using jsonwebtoken crate. Translate passport.js OAuth2 strategies to Rust using oauth2 crate. Create middleware functions that verify tokens and extract user information for request processing.",
            "status": "pending",
            "testStrategy": "Test middleware with valid and invalid tokens, verify proper authentication and error responses for unauthorized requests."
          },
          {
            "id": 5,
            "title": "Implement security middleware (CSRF and other security headers)",
            "description": "Convert csrf.js and security.js middleware to Rust with Actix Web middleware for CSRF protection and security headers.",
            "dependencies": [
              "12.1",
              "12.4"
            ],
            "details": "Create Actix middleware for CSRF token generation and validation. Implement security headers middleware similar to Helmet.js functionality. Ensure all security measures from the Node.js backend are preserved or enhanced.",
            "status": "pending",
            "testStrategy": "Test CSRF token validation and verify security headers are properly set in responses."
          },
          {
            "id": 6,
            "title": "Migrate auth routes and endpoints",
            "description": "Convert auth.js routes to Rust Actix Web handlers with registration, login, and OAuth callback endpoints.",
            "dependencies": [
              "12.3",
              "12.4",
              "12.5"
            ],
            "details": "Implement Actix Web routes for all authentication endpoints. Handle user registration, login, OAuth redirects, and token generation. Ensure API compatibility with existing Node.js endpoints including request/response formats and error handling.",
            "status": "pending",
            "testStrategy": "Test all authentication endpoints with various scenarios including successful login, failed login, and OAuth integration."
          },
          {
            "id": 7,
            "title": "Migrate profile routes and user management endpoints",
            "description": "Convert profile.js routes to Rust with user profile retrieval, update, and management functionality.",
            "dependencies": [
              "12.3",
              "12.4",
              "12.6"
            ],
            "details": "Implement Actix Web handlers for profile-related endpoints. Include GET profile, UPDATE profile, and other user management operations. Maintain exact API contract with the existing Node.js implementation.",
            "status": "pending",
            "testStrategy": "Test profile retrieval and update operations, verify data persistence and proper authorization checks."
          },
          {
            "id": 8,
            "title": "Migrate admin and venues routes",
            "description": "Convert admin.js and venues.js routes to Rust Actix Web handlers with proper authorization and business logic.",
            "dependencies": [
              "12.3",
              "12.4",
              "12.7"
            ],
            "details": "Implement admin endpoints with role-based access control and venues management endpoints. Translate all business logic from JavaScript to Rust while maintaining API compatibility. Ensure proper error handling and response formats.",
            "status": "pending",
            "testStrategy": "Test admin endpoints with different user roles, verify authorization works correctly. Test venues CRUD operations and related functionality."
          },
          {
            "id": 9,
            "title": "Implement main server configuration and routing setup",
            "description": "Convert server.js main application setup to Rust with Actix Web server configuration, middleware chain, and route mounting.",
            "dependencies": [
              "12.4",
              "12.5",
              "12.6",
              "12.7",
              "12.8"
            ],
            "details": "Create main application entry point that configures Actix Web server with all middleware, routes, and database connection. Set up proper error handling, logging, and server configuration matching the Node.js server behavior.",
            "status": "pending",
            "testStrategy": "Test server startup, verify all routes are properly mounted and middleware chain works correctly. Test comprehensive API requests to ensure full functionality."
          },
          {
            "id": 10,
            "title": "Create comprehensive test suite and deployment preparation",
            "description": "Develop integration tests for all migrated endpoints and prepare deployment configuration for the Rust backend.",
            "dependencies": [
              "12.9"
            ],
            "details": "Write integration tests using actix-web-test crate to verify all endpoints work correctly. Create Dockerfile and deployment scripts for the Rust application. Set up environment configuration for production deployment. Ensure performance benchmarks show improvement over Node.js version.",
            "status": "pending",
            "testStrategy": "Run comprehensive test suite covering all endpoints and edge cases. Perform load testing to verify performance improvements. Test deployment process in staging environment."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-27T09:33:35.425Z",
      "updated": "2025-08-28T07:37:14.555Z",
      "description": "Tasks for master context"
    }
  }
}